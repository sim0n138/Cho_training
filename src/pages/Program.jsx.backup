/**
 * Program page - Exercise program generation
 * Refactored to use ProgramGenerator component and programService
 */
import Layout from '../components/layout/Layout';
import { ProgramGenerator } from '../components/program';
import './Program.css';

// Helper functions moved outside component
const filterByPain = (exercises, painAreas) => {
  if (painAreas.length === 0) return exercises;

  const conflictAreas = painAreas.flatMap((pain) => PAIN_AREA_MAP[pain] || []);
  return exercises.filter((ex) => {
    return !ex.areas.some((area) => conflictAreas.includes(area));
  });
};

const packByMinutes = (exercises, targetMinutes, tolerance) => {
  if (exercises.length === 0) return [];

  const minMin = targetMinutes * (1 - tolerance);
  const maxMin = targetMinutes * (1 + tolerance);

  let selected = [];
  let currentTotal = 0;
  const available = [...exercises];

  // Greedy packing
  while (currentTotal < maxMin && available.length > 0) {
    // Sort by how close they get us to target
    available.sort((a, b) => {
      const diffA = Math.abs(targetMinutes - (currentTotal + a.duration));
      const diffB = Math.abs(targetMinutes - (currentTotal + b.duration));
      return diffA - diffB;
    });

    const next = available[0];
    if (currentTotal + next.duration <= maxMin) {
      selected.push(next);
      currentTotal += next.duration;
      available.splice(0, 1);
    } else {
      break;
    }

    // Stop if we're in acceptable range
    if (currentTotal >= minMin && currentTotal <= maxMin) {
      break;
    }
  }

  // P1: Final trimming if over maxMin
  while (currentTotal > maxMin && selected.length > 1) {
    // Remove longest exercise
    selected.sort((a, b) => b.duration - a.duration);
    const removed = selected.shift();
    currentTotal -= removed.duration;
  }

  return selected;
};

const getMostFrequentArea = (areas) => {
  if (areas.length === 0) return 'general';
  const counts = {};
  areas.forEach((area) => {
    counts[area] = (counts[area] || 0) + 1;
  });
  return Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0];
};

const getTotalMinutes = (packed) => {
  return Object.values(packed)
    .flat()
    .reduce((sum, ex) => sum + ex.duration, 0);
};

const saveProgramToHistory = (prog) => {
  const history = JSON.parse(localStorage.getItem('program_history') || '[]');
  history.unshift(prog);
  if (history.length > 10) history.pop();
  localStorage.setItem('program_history', JSON.stringify(history));
};

function Program() {
  const [rpe, setRpe] = useState(5);
  const [painAreas, setPainAreas] = useState([]);
  const [program, setProgram] = useState(null);
  const [showRpeModal, setShowRpeModal] = useState(false);
  const [showPainModal, setShowPainModal] = useState(false);

  // Load saved data from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('program_state');
    if (saved) {
      const data = JSON.parse(saved);
      setRpe(data.rpe || 5);
      setPainAreas(data.painAreas || []);
    }
  }, []);

  const generateProgram = useCallback(() => {
    // Get last program's primary area to avoid repetition (P0: fix #1)
    const lastPrograms = JSON.parse(
      localStorage.getItem('program_history') || '[]'
    );
    const lastPrimaryArea =
      lastPrograms.length > 0 ? lastPrograms[0].primaryArea : null;

    // Define target minutes based on RPE
    let targetMinutes = {
      stretch: 15,
      lfc: 20,
      meditation: 10,
    };

    // Adjust based on RPE (high RPE reduces volume)
    if (rpe >= 7) {
      targetMinutes = {
        stretch: 10,
        lfc: 15,
        meditation: 10,
      };
    } else if (rpe <= 3) {
      targetMinutes = {
        stretch: 20,
        lfc: 25,
        meditation: 10,
      };
    }

    // Filter exercises by pain areas
    const filteredExercises = {
      stretch: filterByPain(EXERCISES.stretch, painAreas),
      lfc: filterByPain(EXERCISES.lfc, painAreas),
      meditation: EXERCISES.meditation, // Meditation not affected by pain
    };

    // Filter by RPE level
    const maxLevel = rpe >= 7 ? 1 : 2;
    const availableExercises = {
      stretch: filteredExercises.stretch.filter((ex) => ex.level <= maxLevel),
      lfc: filteredExercises.lfc.filter((ex) => ex.level <= maxLevel),
      meditation: filteredExercises.meditation,
    };

    // P0: fix #3 - Add fallback for empty lists
    if (availableExercises.stretch.length === 0) {
      availableExercises.stretch = EXERCISES.stretch.filter(
        (ex) => ex.level === 1
      );
    }
    if (availableExercises.lfc.length === 0) {
      availableExercises.lfc = EXERCISES.lfc.filter((ex) => ex.level === 1);
    }

    // Pack exercises to target minutes
    const packed = {
      stretch: packByMinutes(
        availableExercises.stretch,
        targetMinutes.stretch,
        MINUTES_TOLERANCE
      ),
      lfc: packByMinutes(
        availableExercises.lfc,
        targetMinutes.lfc,
        MINUTES_TOLERANCE
      ),
      meditation: packByMinutes(
        availableExercises.meditation,
        targetMinutes.meditation,
        MINUTES_TOLERANCE
      ),
    };

    // Determine primary area
    const allAreas = [...packed.stretch, ...packed.lfc]
      .flatMap((ex) => ex.areas)
      .filter((area) => area);
    const primaryArea = getMostFrequentArea(allAreas);

    // P0: fix #1 - Strict check: if primary area matches last, regenerate with forced diversity
    if (primaryArea === lastPrimaryArea && lastPrimaryArea !== null) {
      // Force different area by excluding last primary area exercises
      const diverseExercises = {
        stretch: availableExercises.stretch.filter(
          (ex) => !ex.areas.includes(lastPrimaryArea)
        ),
        lfc: availableExercises.lfc.filter(
          (ex) => !ex.areas.includes(lastPrimaryArea)
        ),
        meditation: availableExercises.meditation,
      };

      // Ensure we still have exercises after filtering
      if (
        diverseExercises.stretch.length > 0 ||
        diverseExercises.lfc.length > 0
      ) {
        const newPacked = {
          stretch: packByMinutes(
            diverseExercises.stretch,
            targetMinutes.stretch,
            MINUTES_TOLERANCE
          ),
          lfc: packByMinutes(
            diverseExercises.lfc,
            targetMinutes.lfc,
            MINUTES_TOLERANCE
          ),
          meditation: packByMinutes(
            diverseExercises.meditation,
            targetMinutes.meditation,
            MINUTES_TOLERANCE
          ),
        };

        const newPrimaryArea = getMostFrequentArea(
          [...newPacked.stretch, ...newPacked.lfc].flatMap((ex) => ex.areas)
        );

        const newProgram = {
          date: new Date().toISOString(),
          primaryArea: newPrimaryArea,
          exercises: newPacked,
          totalMinutes: getTotalMinutes(newPacked),
        };

        setProgram(newProgram);
        saveProgramToHistory(newProgram);
        return;
      }
    }

    const newProgram = {
      date: new Date().toISOString(),
      primaryArea,
      exercises: packed,
      totalMinutes: getTotalMinutes(packed),
    };

    setProgram(newProgram);
    saveProgramToHistory(newProgram);
  }, [rpe, painAreas]);

  // Generate program on mount or when parameters change
  useEffect(() => {
    generateProgram();
  }, [generateProgram]);

  const handleSaveRpe = (newRpe) => {
    setRpe(newRpe);
    const state = { rpe: newRpe, painAreas };
    localStorage.setItem('program_state', JSON.stringify(state));
    setShowRpeModal(false);
  };

  const handleSavePain = (newPainAreas) => {
    setPainAreas(newPainAreas);
    const state = { rpe, painAreas: newPainAreas };
    localStorage.setItem('program_state', JSON.stringify(state));
    setShowPainModal(false);
  };

  return (
    <Layout>
      <div className="program-container">
        <h2>Программа на сегодня</h2>
        <p className="description">
          Вариативная программа-генератор с учётом RPE и самочувствия
        </p>

        <section className="controls">
          <Card>
            <div className="control-item">
              <span>RPE (нагрузка): {rpe}/10</span>
              <Button variant="secondary" onClick={() => setShowRpeModal(true)}>
                Изменить
              </Button>
            </div>
            <div className="control-item">
              <span>
                Боль: {painAreas.length === 0 ? 'Нет' : painAreas.join(', ')}
              </span>
              <Button
                variant="secondary"
                onClick={() => setShowPainModal(true)}
              >
                Изменить
              </Button>
            </div>
          </Card>
        </section>

        {program && (
          <section className="program-content">
            <Card>
              <h3>
                Растяжка (
                {program.exercises.stretch.reduce((s, e) => s + e.duration, 0)}{' '}
                мин)
              </h3>
              {program.exercises.stretch.length === 0 ? (
                <p className="empty-state">Без конкретных упражнений</p>
              ) : (
                <ul className="exercise-list">
                  {program.exercises.stretch.map((ex) => (
                    <li key={ex.id}>
                      {ex.name} — {ex.duration} мин
                    </li>
                  ))}
                </ul>
              )}
            </Card>

            <Card>
              <h3>
                ЛФК ({program.exercises.lfc.reduce((s, e) => s + e.duration, 0)}{' '}
                мин)
              </h3>
              {program.exercises.lfc.length === 0 ? (
                <p className="empty-state">Без конкретных упражнений</p>
              ) : (
                <ul className="exercise-list">
                  {program.exercises.lfc.map((ex) => (
                    <li key={ex.id}>
                      {ex.name} — {ex.duration} мин
                    </li>
                  ))}
                </ul>
              )}
            </Card>

            <Card>
              <h3>
                Медитация (
                {program.exercises.meditation.reduce(
                  (s, e) => s + e.duration,
                  0
                )}{' '}
                мин)
              </h3>
              {program.exercises.meditation.length === 0 ? (
                <p className="empty-state">Без конкретных упражнений</p>
              ) : (
                <ul className="exercise-list">
                  {program.exercises.meditation.map((ex) => (
                    <li key={ex.id}>
                      {ex.name} — {ex.duration} мин
                    </li>
                  ))}
                </ul>
              )}
            </Card>

            <Card>
              <div className="program-summary">
                <p>
                  <strong>Всего:</strong> {program.totalMinutes} минут
                </p>
                <p>
                  <strong>Доминирующая область:</strong> {program.primaryArea}
                </p>
                <Button variant="primary" onClick={generateProgram}>
                  Перегенерировать
                </Button>
              </div>
            </Card>
          </section>
        )}
      </div>

      {/* P0: fix #4 - Accessible modals */}
      {showRpeModal && (
        <RpeModal
          currentRpe={rpe}
          onSave={handleSaveRpe}
          onClose={() => setShowRpeModal(false)}
        />
      )}

      {showPainModal && (
        <PainModal
          currentPainAreas={painAreas}
          onSave={handleSavePain}
          onClose={() => setShowPainModal(false)}
        />
      )}
    </Layout>
  );
}

// P0: fix #4 - Accessible RPE Modal with focus trap
function RpeModal({ currentRpe, onSave, onClose }) {
  const [rpe, setRpe] = useState(currentRpe);
  const modalRef = useRef(null);
  const firstFocusRef = useRef(null);
  const previousFocusRef = useRef(null);

  useEffect(() => {
    // Save previous focus
    previousFocusRef.current = document.activeElement;

    // Block background scroll
    document.body.style.overflow = 'hidden';

    // Focus first element
    if (firstFocusRef.current) {
      firstFocusRef.current.focus();
    }

    // Handle Escape key
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', handleEscape);

    return () => {
      // Restore scroll
      document.body.style.overflow = '';

      // Restore focus
      if (previousFocusRef.current) {
        previousFocusRef.current.focus();
      }

      document.removeEventListener('keydown', handleEscape);
    };
  }, [onClose]);

  // Focus trap
  const handleKeyDown = (e) => {
    if (e.key === 'Tab') {
      const focusableElements = modalRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (e.shiftKey && document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      } else if (!e.shiftKey && document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  };

  return (
    <div className="modal-overlay" onClick={onClose} aria-hidden="true">
      <div
        ref={modalRef}
        className="modal-content"
        role="dialog"
        aria-modal="true"
        aria-labelledby="rpe-modal-title"
        onClick={(e) => e.stopPropagation()}
        onKeyDown={handleKeyDown}
      >
        <h3 id="rpe-modal-title" ref={firstFocusRef} tabIndex={-1}>
          Выберите RPE (нагрузка)
        </h3>
        <p className="modal-description">
          1-3: Низкая, 4-6: Средняя, 7-10: Высокая
        </p>
        <div className="rpe-scale">
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((value) => (
            <button
              key={value}
              className={`rpe-button ${rpe === value ? 'active' : ''}`}
              onClick={() => setRpe(value)}
              aria-pressed={rpe === value}
              aria-label={`RPE ${value}`}
            >
              {value}
            </button>
          ))}
        </div>
        <div className="modal-actions">
          <Button variant="primary" onClick={() => onSave(rpe)}>
            Сохранить
          </Button>
          <Button variant="secondary" onClick={onClose}>
            Отмена
          </Button>
        </div>
      </div>
    </div>
  );
}

// P0: fix #4 - Accessible Pain Modal
function PainModal({ currentPainAreas, onSave, onClose }) {
  const [selectedAreas, setSelectedAreas] = useState(currentPainAreas);
  const modalRef = useRef(null);
  const firstFocusRef = useRef(null);
  const previousFocusRef = useRef(null);

  useEffect(() => {
    previousFocusRef.current = document.activeElement;
    document.body.style.overflow = 'hidden';

    if (firstFocusRef.current) {
      firstFocusRef.current.focus();
    }

    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', handleEscape);

    return () => {
      document.body.style.overflow = '';
      if (previousFocusRef.current) {
        previousFocusRef.current.focus();
      }
      document.removeEventListener('keydown', handleEscape);
    };
  }, [onClose]);

  const handleKeyDown = (e) => {
    if (e.key === 'Tab') {
      const focusableElements = modalRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (e.shiftKey && document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      } else if (!e.shiftKey && document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  };

  const toggleArea = (area) => {
    if (selectedAreas.includes(area)) {
      setSelectedAreas(selectedAreas.filter((a) => a !== area));
    } else {
      setSelectedAreas([...selectedAreas, area]);
    }
  };

  return (
    <div className="modal-overlay" onClick={onClose} aria-hidden="true">
      <div
        ref={modalRef}
        className="modal-content"
        role="dialog"
        aria-modal="true"
        aria-labelledby="pain-modal-title"
        onClick={(e) => e.stopPropagation()}
        onKeyDown={handleKeyDown}
      >
        <h3 id="pain-modal-title" ref={firstFocusRef} tabIndex={-1}>
          Области боли
        </h3>
        <p className="modal-description">
          Выберите области, в которых испытываете боль или дискомфорт
        </p>
        <div className="pain-areas">
          {Object.keys(PAIN_AREA_MAP).map((area) => (
            <button
              key={area}
              className={`pain-button ${selectedAreas.includes(area) ? 'active' : ''}`}
              onClick={() => toggleArea(area)}
              aria-pressed={selectedAreas.includes(area)}
            >
              {area}
            </button>
          ))}
        </div>
        <div className="modal-actions">
          <Button variant="primary" onClick={() => onSave(selectedAreas)}>
            Сохранить
          </Button>
          <Button variant="secondary" onClick={onClose}>
            Отмена
          </Button>
        </div>
      </div>
    </div>
  );
}

RpeModal.propTypes = {
  currentRpe: PropTypes.number.isRequired,
  onSave: PropTypes.func.isRequired,
  onClose: PropTypes.func.isRequired,
};

PainModal.propTypes = {
  currentPainAreas: PropTypes.array.isRequired,
  onSave: PropTypes.func.isRequired,
  onClose: PropTypes.func.isRequired,
};

export default Program;
